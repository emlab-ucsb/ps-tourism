#Pristine seas tourism-MPA model
#Author: Reniel Cabral
#Last Edit: 18 May 2021
#3 August 2021

#To do:
#1. Goal: Biomass model. Adding an MPA, how much biomass will increase at a site?
#2. What I found so far: Maybe challenging to model if per species. For the biomass, we do not need the identity of the species.
#We have a separate model for the biodiversity change.
#3. Simplification --- Biomass as a single species. Need to check how to model dispersal??? For growth, we could get the average r.
#average movement also? well, this assumption cannot capture site-specific differences but maybe we do not need to be accurate.
#4. Add MPA code. Add the current MPA and implement a code where each area is closed and calculate biomass change.


#Biomass model - add MPAs, how much biomass will change?
#1st: define current B/Bmsy and equilibrium B/Bmsy given F/Fmsy
#we do not care about catch transition but we care about B/Bmsy transition.

gc()
rm(list = ls())

library(doParallel)
library(raster)
library(rgdal)
library(maptools)
library(dplyr)
library(cowplot)
library(reshape)
library(scales)
library(maps)
library(sf)
library(tidyverse)
library(patchwork)
library(data.table)
library(here)

#load EEZ mollweide file
Final_EEZ_file_with_names <- readRDS(here("data","Final_EEZ_file_with_names.rds"))
head(Final_EEZ_file_with_names)

#Plot World
Final_EEZ_file_with_names %>% ggplot(aes(x=lon,y=lat,fill=1)) + geom_raster()

#load other files
#land_shp_moll <- readRDS(here("data","land_shp_moll.rds"))
MPA_coord <- readRDS(here("data","MPA_coord_mollweide.rds"))
CleanCoordmegacell<-readRDS(here("data","CleanCoordmegacell_mollweide.rds"))
dim(CleanCoordmegacell)

#land_shp_moll<-readRDS(file = "/Users/ren/Documents/CODES/FoodProvision/land_shp_moll.rds")
#MegaData<-readRDS(file = "/Users/ren/Documents/GitHub/FoodProvison_SupportFiles/Code Food Provision MPA/MegaData_Ray.rds")
#Cleanmegacell<-readRDS(file = "/Users/ren/Documents/GitHub/FoodProvison_SupportFiles/Code Food Provision MPA/Cleanmegacell_mollweide.rds")
#CleanCoordmegacell<-readRDS(file = "/Users/ren/Documents/GitHub/FoodProvison_SupportFiles/Code Food Provision MPA/CleanCoordmegacell_mollweide.rds")
dim(CleanCoordmegacell2)
#this can be used to calculate the % of species range in protected area
#KprotectedPerCell_Library<-readRDS(file = "/Users/ren/Documents/GitHub/FoodProvison_SupportFiles/Code Food Provision MPA/KprotectedPerCell_Library_mollweide.rds")
#MPA_coord<-readRDS(file="/Users/ren/Documents/GitHub/FoodProvison_SupportFiles/Code Food Provision MPA/MPA_coord_mollweide.rds")
MPA_coord$MPA<-1 
head(MPA_coord)
dim(MPA_coord)

#get MPA positions
CleanCoordmegacell_MPA<-left_join(CleanCoordmegacell,MPA_coord,by=c("lon","lat"))
head(CleanCoordmegacell_MPA)
dim(CleanCoordmegacell_MPA)
#positions of 1s
MPAposition<-which(CleanCoordmegacell_MPA$MPA==1)
head(MPAposition)
length(MPAposition)

#join eez and clean coord file with MPA
CleanCoordmegacell_EEZ_wMPA<-left_join(CleanCoordmegacell_MPA,Final_EEZ_file_with_names,by=c("lon","lat"))
#convert NA to 0, then plot MPA file to check
CleanCoordmegacell_EEZ_wMPA$MPA[is.na(CleanCoordmegacell_EEZ_wMPA$MPA)] <- 0
head(CleanCoordmegacell_EEZ_wMPA)
dim(CleanCoordmegacell_EEZ_wMPA)

#plot MPAs
CleanCoordmegacell_EEZ_wMPA %>% filter(MPA==1)  %>%  ggplot(aes(x=lon,y=lat,fill=1)) + geom_raster() #ok, great
#Plot world
CleanCoordmegacell_EEZ_wMPA %>%  ggplot(aes(x=lon,y=lat,fill=1)) + geom_raster() #ok, great
head(CleanCoordmegacell_EEZ_wMPA)
#review
#CleanCoordmegacell_EEZ_wMPA contans the lat, lon, MPA or not, territory, and soverignity

#add biol parameters placeholder and i.d.
biol_data <- CleanCoordmegacell_EEZ_wMPA %>% select(lon, lat, MPA) %>% mutate(r=0.5, K=1000, E=0.25, B=1000) %>% mutate(pos1 = row_number()) #B=K*runif(n(), min=0, max=1)
max(biol_data$pos1)
head(biol_data)
dim(biol_data)[1]

# create distance matrix
#test
sqrt((biol_data[1,1]-biol_data[2,1])^2+(biol_data[1,2]-biol_data[2,2])^2) #50100 unit in meters -- so this is 50km or 0.5 degree
(n_pixel <- dim(biol_data)[1]) #there are 120294 pixels

# #IMPORTANT -- JUST RUN ONCE. COMMENTED FOR NOW. JUST LOAD THE OUTPUT.
# #Option 1 for computing the distance matrix is good
# #permutation with no repetition, and only store the elements within the x km dispersal distance
# dispersal_distance_lim<-1000 #let us say a limit of 1000km as the dispersal distance range...realistic?
# distance_mat<-list()
# cores<-detectCores()
# registerDoParallel(cores-1)
# for (i in 1:n_pixel){ #calculate the distance of pixel i to all (except itself and no repetition, i.e., the half of the distance matrix)
#   distance <- sqrt((biol_data[i,1]-biol_data[i+1:n_pixel,1])^2+(biol_data[i,2]-biol_data[i+1:n_pixel,2])^2)/1000
#   position <- which(distance<=dispersal_distance_lim)
# 
#   if (length(position)==0){next} #in case zero data
# 
#   #save i,j,distance
#   prep_data<-as.data.frame(distance[position])
#   colnames(prep_data) <- "dist"
#   prep_data$pos1<-i
#   prep_data$pos2<-position+i
# 
#   distance_mat[[i]] <- prep_data
# }
# distance_mat_merged <- do.call("rbind",distance_mat)
# stopImplicitCluster()
# head(distance_mat_merged)
# dim(distance_mat_merged)
# max(distance_mat_merged$pos1)
# max(distance_mat_merged$pos2)
# #save the data then load so we do not need to run the code above
# saveRDS(distance_mat_merged, file = "/Users/ren/Documents/GitHub/tourism-mpa/data/distance_mat_merged.rds")

distance_mat_merged <- readRDS(here("data","distance_mat_merged.rds"))
dim(distance_mat_merged)
head(distance_mat_merged)

# #Option 2 for computing the distance matrix is slow. Option 1 is the best.
# n_pixel<-100 #placeholder
# dispersal_distance_lim<-110 #km #for now 100 but realistically 1000?
# distance_mat<-list()
# t <- 1
# for (i in 1:n_pixel){
#   for (j in i+1:n_pixel){ #i'll remove the distance of pixel i from itself which is zero
#     distance <- sqrt((biol_data[i,1]-biol_data[j,1])^2+(biol_data[i,2]-biol_data[j,2])^2)/1000
#     if( distance <= dispersal_distance_lim ){
#       distance_mat[[t]] <- c(i,j,distance)
#       t <- t+1
#     }
#   }
# }
# #
# distance_mat_merged2 <- do.call("rbind",distance_mat)
# head(distance_mat_merged2)
# dim(distance_mat_merged2)

#Complete the distance matrix by adding in the self-loop and the other part of the mirror matrix

#the second mirror half of the matrix
distance_mat_part2 <- distance_mat_merged %>% select(dist,pos2,pos1) 
colnames(distance_mat_part2) <- c("dist","pos1","pos2")
head(distance_mat_part2)

#the link to itself
distance_mat_part3 <- data.frame(dist = rep(0,n_pixel)) %>% mutate(pos1 = 1:n_pixel, pos2 = 1:n_pixel)
head(distance_mat_part3)

#now, combine the three datasets to complete the matrix
distance_mat_full<-rbind(distance_mat_merged,distance_mat_part2,distance_mat_part3)
dim(distance_mat_full)


##ADD a column indicating the proportion of biomass that will move at a specific site. Use a gaussian dispersal.
sigma <- 100
#use group_by, remove the distance column
distance_mat_full_prop <- distance_mat_full %>% group_by(pos1) %>% mutate(biom_prop = exp(-( dist^2 / (2*(sigma^2))) ), biom_prop = biom_prop/sum(biom_prop)) %>% select(-dist)
head(distance_mat_full_prop) #fast!
#check if correct
distance_mat_full_prop %>% filter(pos1==1) %>% summarise(sum(biom_prop)) #ok good

#ok, now that we have the distance matrix, implement biomass diffusion and larval dispersal 
head(biol_data)

biom <- biol_data %>% select(pos1,B)
head(biom)

# # #This code is working and is based on data.frame! But it seems that data.table is faster. So I will comment this.
# cores<-detectCores()
# registerDoParallel(cores-1)
# ptm <- proc.time()
# for (t in 1:30){
#   biom <- left_join(distance_mat_full_prop, biom, by = "pos1") %>% mutate(Bdist=B*biom_prop) %>% group_by(pos2) %>% select(pos2,Bdist) %>% summarize(B=sum(Bdist))
#   colnames(biom) <- c("pos1","B") #now, make the output biomass as input biomass to our next iteration.
# }
# stopImplicitCluster()
# (proc.time() - ptm)/60 #check process time in minutes
# head(biom)

#test how fast is data.table
biom <- data.table(biom)
distance_mat_full_prop <- data.table(distance_mat_full_prop)
head(biom)
head(distance_mat_full_prop)

setkey(distance_mat_full_prop,pos1)
setkey(biom,pos1)

test1<-distance_mat_full_prop[biom]
head(test1)
dim(test1)

test2<-merge(distance_mat_full_prop,biom, all.x=TRUE)
head(test2)
dim(test2)

ptm <- proc.time()
Result2 <- merge(distance_mat_full_prop,biom, all.x=TRUE) %>% mutate(Bdist=B*biom_prop) %>% group_by(pos2) %>% select(pos2,Bdist) %>% summarize(B=sum(Bdist))
(proc.time() - ptm)/60 #check process time in minutes
head(Result2)

testme<-distance_mat_full_prop[biom] %>% mutate(Bdist=B*biom_prop) %>% group_by(pos2) %>% select(pos2,Bdist) %>% summarize(B=sum(Bdist))
head(testme)
colnames(testme) <- c("pos1","B")

#ok, data.table is much faster! Nearly double the speed. Let us model using data.table!!!

head(biol_data)
E <- biol_data$E #we can make this dynamic. i.e., as MPA size increases, E changes.
MPAcell <- biol_data$MPA
rK<-biol_data %>% select(pos1,r,K) %>% as.data.table()
setkey(rK,pos1)
distance_mat_full_prK<-distance_mat_full_prop[rK]
#distance_mat_full_prKE<-merge(distance_mat_full_prop,rKE, all.x=TRUE)
head(distance_mat_full_prK)

#check the file
distance_mat_full_prK %>% group_by(pos1) %>% summarise(propor=sum(biom_prop)) %>% head()

#biomass in next time step = biomass with diffusion - harvest + growth in the form of larval dispersal 

biom_diff <- biom

cores<-detectCores()
registerDoParallel(cores-1)
ptm <- proc.time()
for (t in 1:30){
  
#  biom_test <- merge(distance_mat_full_prKE,biom_diff, all.x=TRUE) %>% mutate(Bdist=B*biom_prop, Growth=biom_prop*r*B*(1-(B/K))) %>% group_by(pos2) %>% select(pos2,Bdist,Growth) %>% summarize(B_add=sum(Bdist),G_add=sum(Growth)) %>% 
#    mutate(B=((1-E)*B_add)+G_add) %>% dplyr::rename(pos1 = pos2) %>% select(pos1,B) %>% as.data.table()
  
  biom_diff <- distance_mat_full_prK[biom_diff] %>% mutate(Bdist=B*biom_prop, Growth=biom_prop*r*B*(1-(B/K))) %>% group_by(pos2) %>% select(pos2,Bdist,Growth) %>% summarize(B_add=sum(Bdist),G_add=sum(Growth)) %>% 
    mutate(B=((1-(E*(1-MPAcell)))*B_add)+G_add) %>% dplyr::rename(pos1 = pos2) %>% select(pos1,B) %>% as.data.table()
  
  #colnames(biom_diff) <- c("pos1","B") #now, make the output biomass as input biomass to our next iteration.
  #biom_diff <- data.table(biom_diff)
}
stopImplicitCluster()
(proc.time() - ptm)/60 #check process time in minutes
head(biom_diff)

CleanCoordmegacell_EEZ_wMPA$B<-biom_diff$B 
CleanCoordmegacell_EEZ_wMPA %>%  ggplot(aes(x=lon,y=lat,fill=B)) + geom_raster() #ok, great


#NOTE:
#1) make distance calculation more realistic
#2) The B for now is fine. Need to decide if the diffusion model is ok. The drawback is the edge effect.
#3) Model the effect of MPA

#MODEL the effect of MPA


#Toy model
#Empirically derived parameters
Qd0 <- 100 #current number of dives
P0 <- 50 #current price per dive in USD
C0 <- 150 #choke price in USD
alpha <- 0.5
beta <- 0.5
X0 <- 10 #dive price (USD) where no company will offer their service
nu <- 1.1

#Model intermediate output
deltaB <- 20 #change in biomass
deltaS <- 10 #change in species diversity metric

#Parameter calculations
#we need a and b to compute mu
(a <- (C0*Qd0)/(C0-P0))
(b <- Qd0/(C0-P0))
(mu <- nu*(a-(b*P0))) #assume that MPA will increase the demand for diving by 10%.

(e <- (a-(b*P0))/(P0-X0)) #Slope of the supply curve
(c <- (((b*P0)-a)*X0)/(P0-X0)) #Dive quantity supplied by the industry when the price of diving is zero

(P1 <- (a-c+mu+(alpha*deltaB)+(beta*deltaS))/(e+b)) #Price per dive at site i when the site is converted to an MPA
(Qd1 <- a-(b*P1)+mu+(alpha*deltaB)+(beta*deltaS)) #Number of dives at site i when the site is converted to an MPA
(C1 <- (a+mu+(alpha*deltaB)+(beta*deltaS))/b)

##Tourism model output
#Change in tourism revenue at site i
(P1*Qd1) - (P0*Qd0)

#Change in counsumer surplus
(0.5*(C1-P1)*Qd1) - (0.5*(C0-P0)*Qd0)

#Change in consumer + producer surplus
(Qd0*(C1-C0)) + (0.5*(Qd1-Qd0)*(C1-C0))
